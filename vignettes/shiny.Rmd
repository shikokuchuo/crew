---
title: "Asynchronous Shiny apps"
author: "Will Landau and Daniel Woodie"
output:
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Asynchronous Shiny apps}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# About

`crew` is efficient to use in Shiny apps, and the [centralized controller](https://wlandau.github.io/crew/reference/crew_class_controller.html) makes the programming easy, even if there are thousands of tasks.

# Example: coin flips

This app simulates thousands of coin flips to determine if a coin is fair. Each coin flip is a task, and `crew` runs the tasks in parallel. When you run the app, the clock keeps ticking even while coin flips are running. In other words, parallel tasks run in the background and the app stays interactive. This is easily achieved without relying on [promises](https://rstudio.github.io/promises/) or [Shiny extended tasks](https://shiny.posit.co/r/reference/shiny/latest/extendedtask).


## Tutorial

We first load Shiny.

```r
library(shiny)
```

The `flip_coin()` function simulates a coin flip: wait 0.1 seconds, then randomly return 1 for heads or 0 for tails. After many flips, the user may deduce that the coin is slightly unfair.

```r
flip_coin <- function() {
  Sys.sleep(0.1)
  rbinom(n = 1, size = 1, prob = 0.501)
}
```

The UI has a button to flip coins and a text output for results.

```r
ui <- fluidPage(
  div("Is the coin fair?"),
  actionButton("button", "Flip 1000 coins"),
  textOutput("results")
)
```

In the server, we start by creating a `crew` controller which will simulate coin flips in parallel across 10 parallel workers. `seconds_idle = 10` means each worker automatically exits if it idles for 10 seconds.

```r
server <- function(input, output, session) {
  controller <- crew::crew_controller_local(workers = 10, seconds_idle = 10)
  controller$start()
  onStop(function() controller$terminate())
```

We keep running totals of heads, tails, and total flips. 

```r
  flips <- reactiveValues(heads = 0, tails = 0, total = 0)
```

The action button submits a batch of 1000 coin flips.

```r
  observeEvent(input$button, {
    controller$walk(
      command = flip_coin(),
      iterate = list(index = seq_len(1000)),
      data = list(flip_coin = flip_coin)
    )
  })
```

We include an `observe()` statement to watch for finished coin flips and update the totals every 0.5 seconds.

```r
  observe({
    invalidateLater(millis = 500)
    results <- controller$collect(error = "stop")
    req(results)
    new_flips <- as.logical(results$result)
    flips$heads <- flips$heads + sum(new_flips)
    flips$tails <- flips$tails + sum(1 - new_flips)
    flips$total <- flips$total + length(new_flips)
  })
```

Finally, our text output refreshes every 0.5 seconds to update the clock and the totals.


A text output refreshes to show the current time and the number of coin flips submitted but not yet completed. The refresh happens when a batch of coin flips is submitted, a coin flip completes, or a full second has passed.

```r
  output$results <- renderText({
    invalidateLater(millis = 500)
    pattern <- "%s | %s heads, %s tails, %s total"
    time <- format(Sys.time(), "%H:%M:%S")
    sprintf(pattern, time, flips$heads, flips$tails, flips$total)
  })
}
```

## Full app code

```r
library(shiny)

flip_coin <- function() {
  Sys.sleep(0.1)
  rbinom(n = 1, size = 1, prob = 0.501)
}

ui <- fluidPage(
  div("Is the coin fair?"),
  actionButton("button", "Flip 1000 coins"),
  textOutput("results")
)

server <- function(input, output, session) {
  # crew controller
  controller <- crew::crew_controller_local(workers = 10, seconds_idle = 10)
  controller$start()
  onStop(function() controller$terminate())
  
  # Keep running totals of heads, tails, and total flips.
  flips <- reactiveValues(heads = 0, tails = 0, total = 0)
  
  # Flip a batch of coins when the button is pressed.
  observeEvent(input$button, {
    controller$walk(
      command = flip_coin(),
      iterate = list(index = seq_len(1000)),
      data = list(flip_coin = flip_coin)
    )
  })

  # Collect coin flip results.
  observe({
    invalidateLater(millis = 500)
    results <- controller$collect(error = "stop")
    req(results)
    new_flips <- as.logical(results$result)
    flips$heads <- flips$heads + sum(new_flips)
    flips$tails <- flips$tails + sum(1 - new_flips)
    flips$total <- flips$total + length(new_flips)
  })
  
  # Print time and flip counts.
  output$results <- renderText({
    invalidateLater(millis = 500)
    pattern <- "%s | %s heads, %s tails, %s total"
    time <- format(Sys.time(), "%H:%M:%S")
    sprintf(pattern, time, flips$heads, flips$tails, flips$total)
  })
}

shinyApp(ui = ui, server = server)
```

# Example: generative art

The app below demonstrates how `crew` integrates with [extended tasks in Shiny](https://shiny.posit.co/r/reference/shiny/latest/extendedtask). This integration, based on the powerful relationship between [`mirai`](https://github.com/shikokuchuo/mirai) and [`promises`](https://rstudio.github.io/promises/), is currently experimental.

The simple example below has three interface elements: an action button, a plot output, and a text output. When you click the action button, a new 5-second task pushes to the `crew` controller. The action button can submit new tasks even when existing tasks are running in the background. The plot output shows the random visualization returned from latest task.

The text output continuously refreshes to show the current time and number of tasks in progress. Watch the short video linked below to see the app in action. As in the previous example, the clock keeps ticking even as tasks run in the background.

[![](./figures/art.png)](https://vimeo.com/927130003)

## Prerequisites

This example app requires `shiny >= 1.8.1.1`, `mirai >= 1.0.0`, and `nanonext >= 1.0.0`. Run the following in R to upgrade your versions of these packages.

```r
install.packages(c("shiny", "mirai", "nanonext"))
```

## Tutorial

To begin, we load Shiny.

```r
library(shiny)
```

The `run_task()` function waits 5 seconds and then generates a random [`aRtsy::canvas_squares()`](https://koenderks.github.io/aRtsy/reference/canvas_squares.html) plot.

```r
run_task <- function() {
  Sys.sleep(5)
  aRtsy::canvas_squares(colors = aRtsy::colorPalette("random-palette"))
}
```

The [user interface](https://shiny.rstudio.com/articles/basics.html) shows the three parts explained previously, along with HTML/CSS formatting.

```r
ui <- fluidPage(
  tags$br(),
  tags$style("#status,#task{font-size:3em}"),
  tags$style("#task{border:3px solid black}"),
  actionButton("task", "Submit a task (5 seconds)"),
  textOutput("status"),
  plotOutput("result")
)
```

The [server](https://shiny.rstudio.com/articles/basics.html) sets up a [local process controller](https://wlandau.github.io/crew/reference/crew_controller_local.html). The controller has 4 workers, and each worker automatically shuts down if 10 seconds pass without any task assignments. `controller$autoscale()` uses a [`later`](https://r-lib.github.io/later/) loop to continuously launch workers to respond to the demand of tasks. The `onStop()` statement says to terminate the controller when the app session terminates.

```r
server <- function(input, output, session) {
  controller <- crew::crew_controller_local(workers = 4, seconds_idle = 10)
  controller$start()
  controller$autoscale()
  onStop(function() controller$terminate())
```

The `cue` object below is a [Shiny extended task](https://rstudio.github.io/shiny/reference/ExtendedTask.html) which accepts a [`mirai`](https://github.com/shikokuchuo/mirai) task object from `controller$push()`. Through the magic of Shiny, `promises`, and [`mirai`](https://github.com/shikokuchuo/mirai), this extended task can invalidate reactive expressions when a `crew` task completes.

```r
  cue <- ExtendedTask$new(func = identity)
```

The "Submit a task (5 seconds)" button pushes a new task to the controller and invokes the extended task.

```r
  observeEvent(
    input$task, 
    cue$invoke(controller$push(run_task(), data = list(run_task = run_task)))
  )
```

`cue$result()` triggers a plot update when a task completes, and we get the actual plot from `controller$pop()` to correctly remove the resolved task from the controller. `error = "stop"` relays any errors from the tasks.

```r
  output$result <- renderPlot({
    cue$result()
    controller$pop(error = "stop")$result[[1]]
  })
```

The text status periodically refreshes to show the current time and the number of tasks in progress. When you run the app, you will see the time tick away even as tasks and promises operate in the background.

```r
  output$status <- renderText({
    input$task
    cue$status()
    invalidateLater(millis = 1000)
    time <- format(Sys.time(), "%H:%M:%S")
    paste("Time:", time, "|", "Running tasks:", controller$unresolved())
  })
}
```

## Full app code

```r
library(shiny)

run_task <- function() {
  Sys.sleep(5)
  aRtsy::canvas_squares(colors = aRtsy::colorPalette("random-palette"))
}

ui <- fluidPage(
  tags$br(),
  tags$style("#status,#task{font-size:3em}"),
  tags$style("#task{border:3px solid black}"),
  actionButton("task", "Submit a task (5 seconds)"),
  textOutput("status"),
  plotOutput("result")
)

server <- function(input, output, session) {
  # crew controller
  controller <- crew::crew_controller_local(workers = 4, seconds_idle = 10)
  controller$start()
  controller$autoscale()
  onStop(function() controller$terminate())

  # extended task to invalidate the plot
  cue <- ExtendedTask$new(func = identity)
  
  # button to submit a crew task
  observeEvent(
    input$task, 
    cue$invoke(controller$push(run_task(), data = list(run_task = run_task)))
  )
  
  # task result
  output$result <- renderPlot({
    cue$result()
    controller$pop(error = "stop")$result[[1]]
  })
  
  # time and task status
  output$status <- renderText({
    input$task
    cue$status()
    invalidateLater(millis = 1000)
    time <- format(Sys.time(), "%H:%M:%S")
    paste("Time:", time, "|", "Running tasks:", controller$unresolved())
  })
}

shinyApp(ui = ui, server = server)
```
